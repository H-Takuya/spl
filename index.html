<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Splatoon3 戦績OCR（CSPセーフ・Chrome向け修正版）</title>
  <style>
    :root { --bg:#0b0b10; --panel:#141420; --text:#e5e7eb; --muted:#9aa0a6; --accent:#22c55e; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--text); }
    header { padding:16px 24px; border-bottom:1px solid #232336; background:#0d0d16; position:sticky; top:0; z-index:10; }
    h1 { margin:0; font-size:18px; font-weight:700; }
    main { display:grid; grid-template-columns: 420px 1fr; gap:16px; padding:16px; }
    @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
    .card { background:var(--panel); border:1px solid #232336; border-radius:16px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    .section { padding:16px; }
    .dropzone { border:2px dashed #303048; border-radius:12px; padding:18px; text-align:center; color:var(--muted); cursor:pointer; }
    .dropzone.drag { border-color:#4f46e5; background:#111126; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn { appearance:none; border:1px solid #2a2a44; background:#1a1a2b; color:#e5e7eb; padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer; }
    .btn:hover { background:#20203a; }
    .btn.accent { border-color:#14532d; background:#052e16; color:#a7f3d0; }
    .btn.warn { border-color:#7f1d1d; background:#2a0f0f; color:#fecaca; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:8px; }
    .grid-3 { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }
    input, select, textarea { width:100%; box-sizing:border-box; background:#0f0f1a; color:#e5e7eb; border:1px solid #2a2a44; border-radius:10px; padding:10px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #232336; padding:8px 10px; text-align:left; font-size:14px; }
    th { color:#9aa0a6; font-weight:600; }
    canvas { width:100%; height:auto; border-radius:12px; background:#0f0f1a; border:1px solid #232336; }
    small { color:#9aa0a6; }
    .muted { color:#9aa0a6; }
    .pill { font-size:12px; padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid #27324f; }
    .hint { font-size:12px; color:#a7f3d0; background:#052e16; border:1px solid #14532d; padding:6px 8px; border-radius:8px; }
  </style>
  <!-- 内蔵Tesseract.jsでオフラインOCR。HEICは必要時に遅延ロード（CSPで失敗する場合あり） -->
</head>
<body>
  <header>
    <h1>Splatoon3 戦績OCR（CSPセーフ／ローカル保存・辞書補正）</h1>
  </header>
  <main>
    <section class="card">
      <div class="section">
        <div id="drop" class="dropzone">
          <strong>スクショをドラッグ＆ドロップ</strong><br>
          <small>PNG/JPG/HEIC 可（端末内のみ画像処理・OCRは選択制）</small>
          <div style="height:8px"></div>
          <input id="file" type="file" accept="image/png,image/jpeg" style="display:none" />
          <div class="row" style="justify-content:center">
            <button id="pick" class="btn">ファイルを選ぶ</button>
            <button id="demo" class="btn">デモ画像</button>
          </div>
        </div>
      </div>
      <div class="section">
        <canvas id="preview" width="1920" height="1080"></canvas>
        <div class="row" style="justify-content:space-between; margin-top:8px">
          <div class="row">
            <span class="pill" id="imgMeta">画像未読込</span>
          </div>
          <div class="row">
            <button id="rotateLeft" class="btn" disabled>↺ 90°</button>
            <button id="rotateRight" class="btn" disabled>↻ 90°</button>
            <button id="auto" class="btn accent" disabled>自動解析</button>
            <button id="reset" class="btn warn" disabled>リセット</button>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="section">
        <div class="row" style="justify-content:space-between; align-items:flex-end">
          <div>
            <div style="font-size:16px; font-weight:700;">抽出結果（編集可・辞書補正ON）</div>
            <small class="muted">誤認識は上書きしてください。ローカル保存。</small>
          </div>
          <div class="row">
            <button id="copyCsv" class="btn" disabled>1行CSVコピー</button>
            <button id="append" class="btn" disabled>一覧に追加</button>
          </div>
        </div>
        <div style="height:12px"></div>
        <div class="row" style="align-items:center; gap:12px; margin-bottom:8px">
          <label class="hint">ローカルOCRは Tesseract.js で動作します。初回解析時はモデル読み込みに数秒かかる場合があります。<br>オンラインOCR（外部送信）は補助用なので、精度不足時のみ有効化してください。</label>
        </div>
        <div class="grid" style="margin-bottom:8px">
          <div>
            <label><input type="checkbox" id="useOnlineOcr"> オンラインOCR（OCR.space / β）を使う</label>
            <small class="muted">※ 画像は外部APIに送信されます。既定はデモキー（制限あり）。</small>
          </div>
          <div>
            <label>OCR.space API Key（任意）</label>
            <input id="ocrApiKey" placeholder="未入力時は demo key を使用" />
          </div>
        </div>

        <div class="grid">
          <div>
            <label>試合日時</label>
            <input id="matchAt" placeholder="2025-08-28 14:10" />
          </div>
          <div>
            <label>ルール</label>
            <input id="mode" placeholder="レギュラー／バンカラ／Xなど" />
          </div>
          <div>
            <label>ステージ</label>
            <input id="stage" placeholder="マテガイ放水路 など" />
          </div>
          <div>
            <label>ブキ</label>
            <input id="weapon" placeholder="わかばシューター など" />
          </div>
        </div>
        <div class="grid-3" style="margin-top:8px">
          <div>
            <label>勝敗</label>
            <select id="result">
              <option value="">未設定</option>
              <option>WIN</option>
              <option>LOSE</option>
            </select>
          </div>
          <div>
            <label>K</label>
            <input id="kills" type="number" inputmode="numeric" />
          </div>
          <div>
            <label>D</label>
            <input id="deaths" type="number" inputmode="numeric" />
          </div>
        </div>
        <div class="grid-3" style="margin-top:8px">
          <div>
            <label>A</label>
            <input id="assists" type="number" inputmode="numeric" />
          </div>
          <div>
            <label>SP</label>
            <input id="specials" type="number" inputmode="numeric" />
          </div>
          <div>
            <label>塗り</label>
            <input id="paint" type="number" inputmode="numeric" />
          </div>
        </div>
        <div style="height:12px"></div>
        <label>備考</label>
        <textarea id="note" rows="2" placeholder="メモ"></textarea>
      </div>
      <div class="section">
        <div class="row" style="justify-content:space-between; align-items:center">
          <div style="font-weight:700">記録一覧（端末ローカル）</div>
          <div class="row">
            <button id="exportCsv" class="btn">CSV書き出し</button>
            <button id="clearAll" class="btn warn">全消去</button>
          </div>
        </div>
        <div style="height:8px"></div>
        <table id="table">
          <thead>
            <tr>
              <th>#</th>
              <th>日時</th>
              <th>勝敗</th>
              <th>ルール</th>
              <th>ステージ</th>
              <th>ブキ</th>
              <th>K</th>
              <th>D</th>
              <th>A</th>
              <th>SP</th>
              <th>塗り</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script src="vendor/tesseract/tesseract.min.js"></script>
  <script>
    // -------------------- ユーティリティ --------------------
    const $ = (id) => document.getElementById(id);
    const FIELDS = ["matchAt","result","mode","stage","weapon","kills","deaths","assists","specials","paint","note"];
    const state = { image:null, originalBitmap:null, imageCanvas:null, width:0, height:0, scaleX:1, scaleY:1, rotation:0, orientationCache:new Map(), rows: JSON.parse(localStorage.getItem("spla-rows")||"[]") };

    // 既知辞書（必要に応じて追加可能）
    const MODES = ['レギュラーマッチ','バンカラマッチ','バンカラマッチ（オープン）','バンカラマッチ（チャレンジ）','Xマッチ','フェス（オープン）','フェス（チャレンジ）','プライベートマッチ','サーモンラン'];
    const STAGES = ['マテガイ放水路','ナメロウ金属','ユノハナ大渓谷','ゴンズイ地区','チョウザメ造船','キンメダイ美術館','マヒマヒリゾート＆スパ','ザトウマーケット','スメーシーワールド','マサバ海峡大橋','マンタマリア号','タラポートショッピングパーク','海女美術大学','ショッツル鉱山','アロワナモール','ネギトロ炭鉱'];
    const WEAPONS = ['わかばシューター','もみじシューター','スプラシューター','プロモデラーMG','N-ZAP85','.52ガロン','.96ガロン','ジェットスイーパー','プライムシューター','シャープマーカー','ボールドマーカー','スプラローラー','ダイナモローラー','カーボンローラー','スプラマニューバー','デュアルスイーパー','スパッタリー','クアッドホッパーブラック','パラシェルター','ノヴァブラスター','ラピッドブラスター','ロングブラスター','クラッシュブラスター','リッター4K','スプラチャージャー','スクイックリンα','スプラスピナー','バレルスピナー','ハイドラント'];

    function drawPreview(){
      const canvas=$("preview");
      if(!canvas) return;
      if(!state.imageCanvas){ const ctx=canvas.getContext("2d"); ctx.clearRect(0,0,canvas.width,canvas.height); return; }
      canvas.width=state.imageCanvas.width;
      canvas.height=state.imageCanvas.height;
      const ctx=canvas.getContext("2d");
      ctx.drawImage(state.imageCanvas,0,0);
    }
    function setImgMeta(){ const meta = state.image? `${state.image.name}  /  ${state.width}×${state.height}  /  回転 ${state.rotation}°` : "画像未読込"; $("imgMeta").textContent=meta; }
    function enableImageActions(b){ const targets=['auto','reset','copyCsv','append','rotateLeft','rotateRight']; for(const id of targets){ const btn=$(id); if(btn) btn.disabled=!b; } }
    function setBusy(b){ const autoBtn=$("auto"); if(!autoBtn) return; autoBtn.disabled = b; autoBtn.dataset.label = autoBtn.dataset.label || autoBtn.textContent; autoBtn.textContent = b ? '解析中…' : autoBtn.dataset.label; }
    function values(){ const v={}; for(const k of FIELDS){ v[k]=($(k).value||"").toString().trim(); } return v; }
    function setValues(v){ for(const k of FIELDS){ if(k in v) $(k).value = v[k]!==undefined && v[k]!==null ? v[k] : ""; } }
    function csvEscape(s){ const t=(s||"").toString(); if(t.indexOf('"')>=0 || t.indexOf(',')>=0 || t.indexOf(String.fromCharCode(10))>=0){ return '"'+t.split('"').join('""')+'"'; } return t; }
    function fmtRow(v){ const a=[v.matchAt,v.result,v.mode,v.stage,v.weapon,v.kills,v.deaths,v.assists,v.specials,v.paint,v.note]; return a.map(csvEscape).join(','); }
    function renderTable(){ const tb=document.querySelector('#table tbody'); tb.innerHTML=''; for(let i=0;i<state.rows.length;i++){ const r=state.rows[i]; const tr=document.createElement('tr'); const cells=[i+1,r.matchAt,r.result,r.mode,r.stage,r.weapon,r.kills,r.deaths,r.assists,r.specials,r.paint,r.note]; for(const c of cells){ const td=document.createElement('td'); td.textContent=c?c:''; tr.appendChild(td);} tb.appendChild(tr);} }
    function saveRows(){ localStorage.setItem('spla-rows', JSON.stringify(state.rows)); }
    function download(name,text){ const blob=new Blob([text],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); URL.revokeObjectURL(url); }

    // HEICライブラリ遅延ロード（必要時のみ読み込み）
    /* HEICライブラリはCSPの影響を受けるため使用しない（PNG/JPGのみ対応） */

    // 画像ロード（HEIC/縦→横 回転対応）
    function isHeic(file){ const name=(file.name||''); return /\.heic$|\.heif$/i.test(name) || (file.type && /(heic|heif)/i.test(file.type)); }
    async function heicToJpegFile(file){
      throw new Error('HEICは未対応です。PNG/JPGに変換してから読み込んでください。');
    }
    function normalizeRotation(rot){ const r=((rot%360)+360)%360; return r===0?0:r===90?90:r===180?180:r===270?270:((Math.round(r/90)%4+4)%4)*90; }
    function createCanvasFromBitmap(bitmap, rotation){ const rot=normalizeRotation(rotation); const swap=rot===90||rot===270; const canvas=document.createElement('canvas'); canvas.width=swap?bitmap.height:bitmap.width; canvas.height=swap?bitmap.width:bitmap.height; const ctx=canvas.getContext('2d'); ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.rotate((rot*Math.PI)/180); ctx.drawImage(bitmap, -bitmap.width/2, -bitmap.height/2); ctx.restore(); return canvas; }
    function getCanvasForRotation(rotation){ if(!state.originalBitmap) return null; const rot=normalizeRotation(rotation); if(!state.orientationCache.has(rot)){ const canvas=createCanvasFromBitmap(state.originalBitmap, rot); state.orientationCache.set(rot, canvas); } return state.orientationCache.get(rot); }
    function setRotation(rotation){ if(!state.originalBitmap) return; const rot=normalizeRotation(rotation); state.rotation=rot; state.imageCanvas=getCanvasForRotation(rot); if(state.imageCanvas){ state.width=state.imageCanvas.width; state.height=state.imageCanvas.height; state.scaleX=state.width/1920; state.scaleY=state.height/1080; } drawPreview(); setImgMeta(); }

    function clamp(value,min,max){ return Math.min(max, Math.max(min, value)); }
    function detectArrowRow(canvas){
      try{
        const ctx=canvas.getContext('2d');
        const {width,height}=canvas;
        if(!width || !height) return null;
        const x0=Math.floor(width*0.02);
        const x1=Math.floor(width*0.12);
        const sampleWidth=Math.max(1, x1 - x0);
        const data=ctx.getImageData(x0,0,sampleWidth,height).data;
        let bestY=-1, bestScore=0;
        for(let y=0;y<height;y++){
          let rowScore=0;
          const base=y*sampleWidth*4;
          for(let x=0;x<sampleWidth;x++){
            const idx=base + x*4;
            const r=data[idx], g=data[idx+1], b=data[idx+2];
            if(r>210 && g>190 && b<160){
              rowScore += (r+g) - b;
            }
          }
          if(rowScore>bestScore){
            bestScore=rowScore;
            bestY=y;
          }
        }
        if(bestScore < 4000) return null;
        return bestY/height;
      }catch(err){
        console.warn('[OCR] detectArrowRow failed', err);
        return null;
      }
    }
    function getPortraitRoiSets(canvas){
      const aspect = canvas.width/canvas.height;
      const detected = detectArrowRow(canvas);
      const fallbackCenter = aspect>2.1 ? 0.64 : 0.6;
      const center = clamp(detected!==null ? detected : fallbackCenter, 0.36, 0.82);
      const rowHalf = 0.095;
      const topLimit = clamp(center - rowHalf, 0.32, 0.75);
      const bottomLimit = clamp(center + rowHalf, topLimit + 0.05, 0.9);
      const rowHeight = bottomLimit - topLimit;
      const base = {
        result:{x:0.39,y:0.1,w:0.24,h:0.16},
        kd:{x:0.55,y:topLimit,w:0.28,h:rowHeight},
        paint:{x:0.84,y:topLimit,w:0.12,h:rowHeight},
        stage:{x:0.63,y:0.14,w:0.32,h:0.12},
        mode:{x:0.36,y:0.03,w:0.28,h:0.09},
        weapon:{x:0.1,y:topLimit,w:0.34,h:rowHeight}
      };
      const alt = {
        result:{x:0.32,y:0.09,w:0.34,h:0.18},
        kd:{x:0.5,y:Math.max(0.3, topLimit-0.02),w:0.32,h:Math.min(0.95, rowHeight+0.04)},
        paint:{x:0.82,y:Math.max(0.3, topLimit-0.02),w:0.15,h:Math.min(0.95, rowHeight+0.04)},
        stage:{x:0.58,y:0.12,w:0.38,h:0.14},
        mode:{x:0.3,y:0.02,w:0.36,h:0.1},
        weapon:{x:0.08,y:Math.max(0.3, topLimit-0.02),w:0.36,h:Math.min(0.95, rowHeight+0.04)}
      };
      return [base, alt];
    }
    function roiSetCandidatesFor(canvas){
      const aspect = canvas.width / canvas.height;
      if(aspect > 1.95){
        return getPortraitRoiSets(canvas);
      }
      return [ROI_SET_A, ROI_SET_B];
    }
    async function fileToBitmap(file){ try{ return await createImageBitmap(file); }catch(e){ const dataUrl=await new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=()=>rej(fr.error); fr.readAsDataURL(file); }); return await new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(createImageBitmap(img)); img.onerror=()=>rej(new Error('画像の読み込みに失敗しました')); img.src=dataUrl; }); } }
    async function safeLoadImage(file){
      try{
        if(!file) throw new Error('ファイル未選択');
        if(isHeic(file)){
          throw new Error('HEICは未対応です。PNG/JPGに変換してから再試行してください。');
        }
        if(!file.type || !file.type.startsWith('image/')) throw new Error('画像ファイルではありません');
        const bmp = await fileToBitmap(file);
        state.image=file; state.originalBitmap=bmp; state.orientationCache=new Map();
        state.orientationCache.set(0, createCanvasFromBitmap(bmp,0));
        setRotation(0);
        enableImageActions(true);
      }catch(err){
        console.error(err);
        alert('画像の読み込みに失敗しました。\n詳細: '+(err&&err.message?err.message:err));
      }
    }
    async function loadDemo(){ try{ const res=await fetch('demo-spla3.jpg'); if(!res.ok) throw new Error('Demo image not found'); const blob=await res.blob(); await safeLoadImage(new File([blob],'demo-spla3.jpg',{type:blob.type})); }catch(e){ alert('デモ画像がありません。手元のスクショを読み込んでください。'); } }

    // ROI（2系統）
    const ROI_SET_A={ result:{x:0.04,y:0.06,w:0.18,h:0.08}, kd:{x:0.74,y:0.62,w:0.20,h:0.10}, paint:{x:0.78,y:0.80,w:0.16,h:0.08}, stage:{x:0.33,y:0.18,w:0.34,h:0.08}, mode:{x:0.33,y:0.11,w:0.34,h:0.06}, weapon:{x:0.16,y:0.62,w:0.28,h:0.10} };
    const ROI_SET_B={ result:{x:0.05,y:0.10,w:0.22,h:0.12}, kd:{x:0.70,y:0.60,w:0.26,h:0.14}, paint:{x:0.75,y:0.78,w:0.20,h:0.10}, stage:{x:0.28,y:0.16,w:0.42,h:0.10}, mode:{x:0.28,y:0.08,w:0.42,h:0.08}, weapon:{x:0.12,y:0.58,w:0.34,h:0.14} };
    function cropToCanvas(src,roi){ const w=src.width,h=src.height; const sx=Math.round(roi.x*w), sy=Math.round(roi.y*h), sw=Math.round(roi.w*w), sh=Math.round(roi.h*h); const out=document.createElement('canvas'); out.width=sw; out.height=sh; out.getContext('2d').drawImage(src,sx,sy,sw,sh,0,0,sw,sh); return out; }
    function upscaleCanvas(src, scale=2){ const out=document.createElement('canvas'); out.width = Math.max(1, Math.round(src.width*scale)); out.height = Math.max(1, Math.round(src.height*scale)); const ctx=out.getContext('2d'); ctx.imageSmoothingEnabled=false; ctx.drawImage(src,0,0,out.width,out.height); return out; }
    function binarizeCanvas(src, threshold=150){ const c=document.createElement('canvas'); c.width=src.width; c.height=src.height; const ctx=c.getContext('2d'); ctx.drawImage(src,0,0); const img=ctx.getImageData(0,0,c.width,c.height); const d=img.data; for(let i=0;i<d.length;i+=4){ const r=d[i],g=d[i+1],b=d[i+2]; const v=(r*299+g*587+b*114)/1000|0; const t=v>threshold?255:0; d[i]=t; d[i+1]=t; d[i+2]=t; d[i+3]=255; } ctx.putImageData(img,0,0); return c; }

    // ----------- OCR 実装（ローカル優先） -----------
    const ocrEngine = {
      worker: null,
      currentLang: null,
      loadedLangs: new Set(),
      initPromise: null
    };

    async function createTesseractWorker(coreFile){
      const worker = await Tesseract.createWorker({
        workerPath: 'vendor/tesseract/worker.min.js',
        corePath: `vendor/tesseract/${coreFile}`,
        langPath: 'vendor/tesseract/lang-data',
        cachePath: 'vendor/tesseract/lang-data'
      });
      await worker.load();
      return worker;
    }

    async function ensureTesseractWorker(lang){
      if(!window.Tesseract || typeof Tesseract.createWorker !== 'function'){
        throw new Error('TESSERACT_NOT_AVAILABLE');
      }
      if(!ocrEngine.worker){
        if(!ocrEngine.initPromise){
          ocrEngine.initPromise = (async () => {
            const candidates = ['tesseract-core-simd.wasm.js', 'tesseract-core.wasm.js'];
            let lastErr = null;
            for(const core of candidates){
              try{
                const worker = await createTesseractWorker(core);
                return worker;
              }catch(err){
                lastErr = err;
                console.warn('[OCR] failed to initialise', core, err);
              }
            }
            throw lastErr || new Error('Tesseract worker initialisation failed');
          })();
        }
        ocrEngine.worker = await ocrEngine.initPromise;
      }
      const parts = lang.split('+');
      const missing = parts.filter(code => !ocrEngine.loadedLangs.has(code));
      if(missing.length){
        await ocrEngine.worker.loadLanguage(missing.join('+'));
        missing.forEach(code => ocrEngine.loadedLangs.add(code));
      }
      if(ocrEngine.currentLang !== lang){
        await ocrEngine.worker.initialize(lang);
        ocrEngine.currentLang = lang;
      }
      return ocrEngine.worker;
    }

    async function recognizeLocally(canvas, lang, kind){
      try{
        const worker = await ensureTesseractWorker(lang);
        const params = {
          tessedit_char_whitelist: '',
          classify_bln_numeric_mode: '0',
          tessedit_pageseg_mode: '7',
          preserve_interword_spaces: '1',
          user_defined_dpi: '150'
        };
        if(kind === 'num'){
          params.tessedit_char_whitelist = '0123456789';
          params.classify_bln_numeric_mode = '1';
        }else if(kind === 'word' && lang === 'eng'){
          params.tessedit_char_whitelist = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        }
        await worker.setParameters(params);
        const { data } = await worker.recognize(canvas);
        return (data && data.text ? data.text : '').replace(/\s+/g,' ').trim();
      }catch(err){
        if(err && err.message === 'TESSERACT_NOT_AVAILABLE'){
          throw err;
        }
        console.warn('[OCR] Local recognition failed', err);
        return '';
      }
    }

    async function ocrSpace(canvas, lang){
      const apiKey = ($("ocrApiKey").value||'').trim() || 'helloworld'; // demo key
      const dataUrl = canvas.toDataURL('image/png');
      const fd = new FormData();
      fd.append('apikey', apiKey);
      fd.append('base64Image', dataUrl);
      fd.append('language', lang==='jpn'?'jpn':'eng');
      fd.append('scale','true');
      fd.append('OCREngine','2');
      let res, j;
      try {
        res = await fetch('https://api.ocr.space/parse/image', { method:'POST', body: fd });
        j = await res.json();
      } catch (netErr) {
        throw new Error('OCR API network error: '+ netErr.message);
      }
      if(!res.ok || j.IsErroredOnProcessing){
        const msg = Array.isArray(j.ErrorMessage) ? j.ErrorMessage.join(',') : (j.ErrorMessage||'');
        throw new Error('OCR API error: '+ (msg || res.status + ' ' + res.statusText));
      }
      const text = (j.ParsedResults && j.ParsedResults[0] && j.ParsedResults[0].ParsedText) || '';
      return text.replace(/\t/g,' ').replace(/\n/g,' ').trim();
    }

    async function detectAndOcr(binCanvas, lang, kind){
      if('TextDetector' in window){
        try{
          const detector = new window.TextDetector();
          const bitmap = await createImageBitmap(binCanvas);
          const boxes = await detector.detect(bitmap);
          if(Array.isArray(boxes) && boxes.length){
            return boxes.map(b=>b.rawValue||'').join(' ').trim();
          }
        }catch(_){/* ignore and fall back */}
      }
      const localLang = lang==='jpn' ? 'jpn+eng' : 'eng';
      try{
        const localText = await recognizeLocally(binCanvas, localLang, kind);
        if(localText){
          return localText;
        }
      }catch(err){
        if(err && err.message === 'TESSERACT_NOT_AVAILABLE'){
          console.warn('[OCR] Tesseract unavailable', err);
        }else{
          console.warn('[OCR] Local engine error', err);
        }
      }
      if($("useOnlineOcr").checked){
        return await ocrSpace(binCanvas, lang);
      }
      if(!window.Tesseract){
        throw new Error('OCR_UNAVAILABLE_LOCAL');
      }
      return '';
    }
    // 正規化・辞書・数値抽出
    function hiraganaToKatakana(s){return (s||'').replace(/[\u3041-\u3096]/g, ch => String.fromCharCode(ch.charCodeAt(0)+0x60));}
    function zenkakuToHankaku(s){return (s||'').replace(/[！-～]/g, ch => String.fromCharCode(ch.charCodeAt(0)-0xFEE0)).replace(/　/g,' ');}    
    function jaNormalize(s){let t=s||''; t=t.replace(/\s+/g,' ').trim(); t=zenkakuToHankaku(t); t=hiraganaToKatakana(t); t=t.replace(/["'`\[\]{}()]/g,''); return t;}
    function levenshtein(a,b){a=a||'';b=b||'';const m=a.length,n=b.length;const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));for(let i=0;i<=m;i++)dp[i][0]=i;for(let j=0;j<=n;j++)dp[0][j]=j;for(let i=1;i<=m;i++)for(let j=1;j<=n;j++){const cost=a[i-1]===b[j-1]?0:1;dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost);}return dp[m][n];}
    function bestMatch(src, cands){const s=jaNormalize(src);let best={label:'',score:0};for(const c of cands){const t=jaNormalize(c);const d=levenshtein(s,t);const denom=Math.max(1,Math.max(s.length,t.length));const score=1-d/denom;if(score>best.score)best={label:c,score};}return best;}
    function extractNumbersInOrder(s){ const nums=[]; let cur=''; for(const ch of (s||'')){ if(ch>='0'&&ch<='9'){ cur+=ch; } else { if(cur.length>0){ nums.push(parseInt(cur,10)); cur=''; } } } if(cur.length>0){ nums.push(parseInt(cur,10)); } return nums; }
    function parseKD(text){ const ns=extractNumbersInOrder((text||'').replace(/\s+/g,'')); const out={}; if(ns.length>=1) out.kills=ns[0]; if(ns.length>=2) out.deaths=ns[1]; if(ns.length>=3) out.assists=ns[2]; return out; }

    async function runOnceWithRoiSet(canvas, ROIS){
      const out={};
      const names=["result","kd","paint","stage","mode","weapon"];
      for(const name of names){
        const roi=ROIS[name];
        const crop=cropToCanvas(canvas,roi);
        const big=upscaleCanvas(crop, 2.2);
        const bin=binarizeCanvas(big, name==='kd'||name==='paint'? 165 : 150);
        try{
          if(name==="kd"||name==="paint"){ out[name] = await detectAndOcr(bin,'eng','num'); }
          else if(name==="result"){ out[name] = await detectAndOcr(bin,'eng','word'); }
          else { out[name] = await detectAndOcr(bin,'jpn','word'); }
        }catch(e){ out[name]=''; }
      }
      return out;
    }

    function recognitionScore(out){ return (bestMatch(out.mode||'', MODES).score + bestMatch(out.stage||'', STAGES).score + bestMatch(out.weapon||'', WEAPONS).score); }

    async function analyzeWithRoiSets(canvas){
      const candidates = roiSetCandidatesFor(canvas);
      let best = null;
      for(const roi of candidates){
        try{
          const out = await runOnceWithRoiSet(canvas, roi);
          const score = recognitionScore(out);
          if(!best || score > best.score){
            best = { score, raw: out };
          }
        }catch(err){
          console.warn('[OCR] analyzeWithRoiSets candidate failed', err);
        }
      }
      return best;
    }


    function postCorrect(out){
      let result='';
      const r=(out.result||'').toUpperCase();
      if(r.includes('WIN')||r.includes('VICTORY')) result='WIN';
      else if(r.includes('LOSE')||r.includes('DEFEAT')||r.includes('LOST')) result='LOSE';
      const kd=parseKD(out.kd||'');
      const paintNum=(out.paint||'').replace(/[^0-9]/g,'');
      const bmMode = bestMatch(out.mode||'', MODES);
      const bmStage = bestMatch(out.stage||'', STAGES);
      const bmWeapon = bestMatch(out.weapon||'', WEAPONS);
      return {
        matchAt:new Date().toISOString().slice(0,16).replace('T',' '),
        result,
        mode: bmMode.score>=0.55 ? bmMode.label : jaNormalize(out.mode||''),
        stage: bmStage.score>=0.55 ? bmStage.label : jaNormalize(out.stage||''),
        weapon: bmWeapon.score>=0.55 ? bmWeapon.label : jaNormalize(out.weapon||''),
        kills: (kd.kills !== undefined ? String(kd.kills) : ''), deaths: (kd.deaths !== undefined ? String(kd.deaths) : ''), assists: (kd.assists !== undefined ? String(kd.assists) : ''), specials:'', paint: paintNum, note:''
      };
    }

    async function autoAnalyze(){
      if(!state.originalBitmap) return;
      setBusy(true);
      try{
        const rotations = Array.from(new Set([state.rotation,0,90,180,270].map(normalizeRotation)));
        let best = null;
        for(const rot of rotations){
          const canvas = getCanvasForRotation(rot);
          if(!canvas) continue;
          const analysis = await analyzeWithRoiSets(canvas);
          if(!best || analysis.score > best.score){
            best = { ...analysis, rotation: rot };
          }
        }
        if(!best){ throw new Error('OCR_NO_RESULT'); }
        setRotation(best.rotation);
        const values = postCorrect(best.raw);
        setValues(values);
        alert('自動解析が完了しました。誤認識は手で直してください。');
      }catch(err){
        const msg = String(err);
        if(msg.includes('OCR_UNAVAILABLE_LOCAL')){
          alert('この環境ではローカルOCRが無効です。オンラインOCRにチェックを入れるか、手入力で補完してください。');
        }else if(msg.includes('OCR_NO_RESULT')){
          alert('自動解析に失敗しました。画像の向きや明るさを調整して再試行してください。');
        }else{
          alert('OCR中にエラー: '+(err&&err.message?err.message:err));
        }
      } finally { setBusy(false); }
    }

    // -------------------- UIイベント --------------------
    $("pick").addEventListener('click',(e)=>{ e.stopPropagation(); $("file").click(); });
    $("demo").addEventListener('click',loadDemo);
    $("file").addEventListener('change', async (e)=>{ const f=e.target.files && e.target.files[0]; if(!f) return; await safeLoadImage(f); });
    const drop=$("drop");
    drop.addEventListener('click',(e)=>{ if(e.target.closest('button') || e.target.closest('input')) return; $("file").click(); });
    drop.addEventListener('dragover',(e)=>{ e.preventDefault(); drop.classList.add('drag'); });
    drop.addEventListener('dragleave',()=> drop.classList.remove('drag'));
    drop.addEventListener('drop', async (e)=>{ e.preventDefault(); drop.classList.remove('drag'); const f=e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if(!f) return; await safeLoadImage(f); });
    $("auto").addEventListener('click',autoAnalyze);
    $("reset").addEventListener('click',()=>{ location.reload(); });
    $("rotateLeft").addEventListener('click',()=>{ if(!state.originalBitmap) return; setRotation(state.rotation - 90); });
    $("rotateRight").addEventListener('click',()=>{ if(!state.originalBitmap) return; setRotation(state.rotation + 90); });
    $("copyCsv").addEventListener('click',async ()=>{ const row=fmtRow(values()); try{ await navigator.clipboard.writeText(row); alert('CSV 1行をコピーしました。'); }catch(err){ const ok = confirm('クリップボードに書き込めませんでした。代わりにCSVをダウンロードしますか？'); if(ok){ download('spla_row.csv', row + String.fromCharCode(10)); } } });
    $("append").addEventListener('click',()=>{ const v=values(); state.rows.push(v); saveRows(); renderTable(); });
    $("exportCsv").addEventListener('click',()=>{ const NL=String.fromCharCode(10); const header=['日時','勝敗','ルール','ステージ','ブキ','K','D','A','SP','塗り','備考'].join(',')+NL; const body=state.rows.map(fmtRow).join(NL); download('splatoon3_records.csv', header + body + (body? NL:'')); });
    $("clearAll").addEventListener('click',()=>{ if(!confirm('ローカルの記録を全消去します。よろしいですか？')) return; state.rows=[]; saveRows(); renderTable(); });

    // -------------------- セルフテスト --------------------
    (function selfTest(){
      const tests = [];
      function assert(name, cond){ tests.push({name, pass: !!cond}); }
      // basic utils
      assert('extractNumbersInOrder', JSON.stringify(extractNumbersInOrder('10K 5D 3A'))===JSON.stringify([10,5,3]));
      assert('jaNormalize', jaNormalize('  ﾏﾃｶﾞｲ 放水路  ')==='マテガイ 放水路');
      assert('bestMatch stage', bestMatch('ﾏﾃｶﾞｲ放水路', STAGES).label==='マテガイ放水路');
      // postCorrect
      assert('postCorrect WIN', (function(){ const v=postCorrect({result:'VICTORY', kd:'10 5 2', paint:'530p', mode:'Xマッチ', stage:'ﾏﾃｶﾞｲ放水路', weapon:'ﾊｲﾄﾞﾗﾝﾄ'}); return v.result==='WIN' && v.kills==='10' && v.deaths==='5' && v.assists==='2' && v.paint==='530' && v.stage==='マテガイ放水路' && v.weapon==='ハイドラント'; })());
      assert('postCorrect keeps zero', (function(){ const v=postCorrect({result:'LOSE', kd:'0 3 5', paint:'120p', mode:'レギュラーマッチ', stage:'マテガイ放水路', weapon:'わかばシューター'}); return String(v.kills)==='0'; })());
      assert('csvEscape quotes', csvEscape('a,"b",c')==='"a,""b"",c"');
      assert('isHeic true', (function(){ const f={name:'photo.HEIC', type:'image/heic'}; return isHeic(f)===true; })());
      console.log('[SelfTest]', tests);
      const failed = tests.filter(t=>!t.pass);
      if(failed.length){ console.warn('SelfTest failed:', failed); }
    })();

    // 初期表示
    renderTable();
  </script>
</body>
</html>
